package com.动态规划;

import java.util.Arrays;

/**
 * 不知道网上的一些解法分析都是些什么鬼，突然就开始动态规划了，一点推理都没有。
 * 而且好几个博客打的字都一样，怕不是大自然的搬运工吧。
 * 这里记录下我自己的思路：
 * 首先观察规律：遍历两个数组，如果遍历到位置i，有A[i]<=A[i-1]，那么此时有两种选择，交换i位置两个数组的元素，或者交换i-1位置两个数组的元素。
 * 此时我们做一下选择：
 * 1、选择交换i位置的元素，那么此时观察A[i],B[i],A[i-1],B[i-1]，此时一定是A[i]>B[i-1]，B[i]>A[i-1]，为什么呢？因为题目说了，一定会有答案，这里可以自己搞几个数据验证下。
 * 想通了这里，我们再往下看。如果我们交换i位置的元素，那么i-1位置的元素就不用交换了，因为通过A[i]>B[i-1]，B[i]>A[i-1]这个推理条件得出，此时经过交换后，到位置i，A和B都已经是严格递增了。
 * 那么我们再假设到位置i-1时，一次都没有交换，那么当前位置i做了这个选择后，交换次数就是1。
 * 这里再举个例子说明：
 * A=[1 3 3]
 * B=[1 2 4]
 * 这里遍历到位置i=2时需要进行交换，交换后得到正确答案，1
 * 再看一个例子：（这里一定要带着 当前位置有两种选择，交换or不交换 这种概念来看例子）
 * A=[0 4 4 5 9]
 * B=[0 1 6 8 10]
 * 这里当i=2时，我们就要多考虑以下了，如果交换i=2位置，那么可能会导致原本i=3保持递增的关系断掉。
 * 但是我们依然还是按照上面的思路来：
 * 1、先交换i=2位置的元素,再交换i=3位置，得到结果 2
 * A=[0 4 6 5 9] A=[0 4 6 8 9]
 * B=[0 1 4 8 10] B=[0 1 4 5 10]
 * 2、先交换i=2位置，再不交换i=3位置，再交换i=2位置，再交换i=1位置，得到结果 3
 * A=[0 4 6 5 9] A=[0 4 4 5 9] A=[0 1 4 5 9]
 * B=[0 1 4 8 10] B=[0 1 6 8 10] B=[0 4 6 8 10]
 * 3、先不交换i=2，交换i=1，得到结果 1
 * A=[0 4 6 5 9]
 * B=[0 1 4 8 10]
 * 那么这里的规律就是：每当遍历到位置i的时候，只有两种选择，要么交换自己，要么不交换自己，每次做出选择时，都可能需要回溯到前面的位置i-1，这里就有可能造成重复计算。
 * 所以我们可以说：每一次数组从i-1扩展到i,i的结果都由i-1的结果来决定，那么根据这句话，我们大概可以想到动态规划。那么具体怎么做呢？
 * 我们都知道动态规划需要记录结果，那么这里我要记录什么呢？记录前一位的结果
 * 这里我们从
 * A=[1]
 * B=[1]
 * 开始推导：
 * 当只有一位时，交换或者不交换，用两个变量来记录：change=[1],noChange = [0]
 * change初始第一位为1，表示，经过1次交换，A,B都是严格递增的数组。
 * 然后我们开始扩展：
 * A=[1,3]
 * B=[1,4]
 * 这里i=1交换的话，可以对应i=0位置两种情况，如果i=0不交换，那么change[1]=noChange[0]+1;如果i=0交换，那么change[1]=change[0]+1;
 * 那么这里两种情况应该取哪种？当然要进行一个比较了，取最小值。
 * 这里i=1不交换的话，也可以对应i=0位置两种情况，如果i=0不交换，那么noChange[1]=noChange[0]，如果i=0交换，那么noChange[1]=change[0];
 * 【但是！！！】 我们不能想当然，这里假设i=0交换或者不交换都要有前提条件，什么条件下需要i=0位置的交换，什么条件下不需要交换。
 * 这里再根据一些条件限制来做进一步总结：
 * if(A[i]>A[i-1] && B[i]>B[i-1]){ // 当符合递增规律时
 * if(A[i]>B[i-1] && B[i]>A[i-1]){ // 并且大于对位数时
 * //  这里交换或者不交换都一样，都不影响i-1位之前的数的递增关系，那么这里到底是交换还是不交换呢？
 * 这里要看i-1位置时，已经交换过的次数和没有交换过的次数。
 * 如果i-1位置交换过，且累计到目前的次数为3，但是i-1位置没有交换过的时候到i-1位的时候交换累计次数是2，那么这里肯定是会选择i-1位没有交换过的次数
 * 所以这里进行对比：
 * change[i] = Math.min(change[i-1],noChange[i-1]) + 1; // 这里的1是假设当前位置我交换了一次
 * noChange[i] = Math.min(change[i-1],noChange[i-1]);
 * }else{ // 那么这里就是并不大于对位数的时候
 * // 如果选择交换当前位置
 * 那么  change[i] = change[i-1] + 1;// 这里举个例子：A=[1,3,4]  ，如果你交换了i=2，那么就肯定要交换i=1，所以就是位置i=1的交换状态的累计次数+当前位置的交换次数
 * B=[1,2,3]
 * noChange[i] = noChange[i-1];// 如果前一位都没有交换，那么当前位置也不用交换
 * }
 * }else{// 如果不符合递增规律，那么就只有一种情况了A[i]>B[i-1] && B[i]>A[i-1]
 * // 所以这里
 * 交换状态[i] = 不交换状态[i-1] + 1; // 因为前提条件A[i]>B[i-1] && B[i]>A[i-1]，所以这里如果交换当前位置的两个数，那么不会对前一个位置的数造成影响
 * 不交换状态[i] = 交换状态[i-1] ; // 如果这里不交换当前位置的数，肯定不符合递增规律，所以需要交换前一个位置的数
 * }
 * 再次说明一下：这里的 change[i] 表示：i位置的数经过交换，能够保持严格递增的累计次数。noChange[i] 表示：不对i位置的两个数进行交换，能够保持严格递增的累计次数。
 * 最后，根据我们的推理，那么我们可以看到，其实每个位置都依赖前一个位置的结果，所以这里需要记录每个位置的累计结果，那么符合动态规划的思路。
 *
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
public class _801_使序列递增的最小交换次数 {
    public int minSwap(int[] nums1, int[] nums2) {
        int len = nums1.length;
        int[][] dp = new int[2][len];
        for (int inner[] : dp) {
            Arrays.fill(inner, Integer.MAX_VALUE);
        }
        dp[0][0] = 0;
        dp[1][0] = 1;
        for (int i = 1; i < nums1.length; i++) {
            if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {
                dp[0][i] = Math.min(dp[0][i], dp[0][i - 1]);
                dp[1][i] = Math.min(dp[1][i], dp[1][i - 1] + 1);
            }
            if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {
                dp[0][i] = Math.min(dp[0][i], dp[1][i - 1]);
                dp[1][i] = Math.min(dp[1][i], dp[0][i - 1] + 1);
            }
        }
        return Math.min(dp[0][len - 1], dp[1][len - 1]);
    }
}
